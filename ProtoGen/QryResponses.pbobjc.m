// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qry_responses.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "QryResponses.pbobjc.h"
#import "Block.pbobjc.h"
#import "Transaction.pbobjc.h"
#import "Primitive.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Account);
GPBObjCClassDeclaration(AccountAsset);
GPBObjCClassDeclaration(AccountAssetResponse);
GPBObjCClassDeclaration(AccountDetailRecordId);
GPBObjCClassDeclaration(AccountDetailResponse);
GPBObjCClassDeclaration(AccountResponse);
GPBObjCClassDeclaration(Asset);
GPBObjCClassDeclaration(AssetResponse);
GPBObjCClassDeclaration(Block);
GPBObjCClassDeclaration(BlockErrorResponse);
GPBObjCClassDeclaration(BlockResponse);
GPBObjCClassDeclaration(EngineReceipt);
GPBObjCClassDeclaration(EngineReceiptsResponse);
GPBObjCClassDeclaration(ErrorResponse);
GPBObjCClassDeclaration(Peer);
GPBObjCClassDeclaration(PeersResponse);
GPBObjCClassDeclaration(PendingTransactionsPageResponse);
GPBObjCClassDeclaration(PendingTransactionsPageResponse_BatchInfo);
GPBObjCClassDeclaration(RolePermissionsResponse);
GPBObjCClassDeclaration(RolesResponse);
GPBObjCClassDeclaration(SignatoriesResponse);
GPBObjCClassDeclaration(Transaction);
GPBObjCClassDeclaration(TransactionsPageResponse);
GPBObjCClassDeclaration(TransactionsResponse);

#pragma mark - QryResponsesRoot

@implementation QryResponsesRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - QryResponsesRoot_FileDescriptor

static GPBFileDescriptor *QryResponsesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"iroha.protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Asset

@implementation Asset

@dynamic assetId;
@dynamic domainId;
@dynamic precision;

typedef struct Asset__storage_ {
  uint32_t _has_storage_[1];
  uint32_t precision;
  NSString *assetId;
  NSString *domainId;
} Asset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = Asset_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Asset__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domainId",
        .dataTypeSpecific.clazz = Nil,
        .number = Asset_FieldNumber_DomainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Asset__storage_, domainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "precision",
        .dataTypeSpecific.clazz = Nil,
        .number = Asset_FieldNumber_Precision,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Asset__storage_, precision),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Asset class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Asset__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Domain

@implementation Domain

@dynamic domainId;
@dynamic defaultRole;

typedef struct Domain__storage_ {
  uint32_t _has_storage_[1];
  NSString *domainId;
  NSString *defaultRole;
} Domain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "domainId",
        .dataTypeSpecific.clazz = Nil,
        .number = Domain_FieldNumber_DomainId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Domain__storage_, domainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "defaultRole",
        .dataTypeSpecific.clazz = Nil,
        .number = Domain_FieldNumber_DefaultRole,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Domain__storage_, defaultRole),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Domain class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Domain__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Account

@implementation Account

@dynamic accountId;
@dynamic domainId;
@dynamic quorum;
@dynamic jsonData;

typedef struct Account__storage_ {
  uint32_t _has_storage_[1];
  uint32_t quorum;
  NSString *accountId;
  NSString *domainId;
  NSString *jsonData;
} Account__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = Account_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domainId",
        .dataTypeSpecific.clazz = Nil,
        .number = Account_FieldNumber_DomainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account__storage_, domainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quorum",
        .dataTypeSpecific.clazz = Nil,
        .number = Account_FieldNumber_Quorum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Account__storage_, quorum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "jsonData",
        .dataTypeSpecific.clazz = Nil,
        .number = Account_FieldNumber_JsonData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Account__storage_, jsonData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountAsset

@implementation AccountAsset

@dynamic assetId;
@dynamic accountId;
@dynamic balance;

typedef struct AccountAsset__storage_ {
  uint32_t _has_storage_[1];
  NSString *assetId;
  NSString *accountId;
  NSString *balance;
} AccountAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountAsset_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountAsset__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountAsset_FieldNumber_AccountId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountAsset__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "balance",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountAsset_FieldNumber_Balance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountAsset__storage_, balance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountAsset class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountAsset__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountAssetResponse

@implementation AccountAssetResponse

@dynamic optNextAssetIdOneOfCase;
@dynamic accountAssetsArray, accountAssetsArray_Count;
@dynamic totalNumber;
@dynamic nextAssetId;

typedef struct AccountAssetResponse__storage_ {
  uint32_t _has_storage_[2];
  uint32_t totalNumber;
  NSMutableArray *accountAssetsArray;
  NSString *nextAssetId;
} AccountAssetResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountAssetsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(AccountAsset),
        .number = AccountAssetResponse_FieldNumber_AccountAssetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountAssetResponse__storage_, accountAssetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountAssetResponse_FieldNumber_TotalNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountAssetResponse__storage_, totalNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nextAssetId",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountAssetResponse_FieldNumber_NextAssetId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AccountAssetResponse__storage_, nextAssetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountAssetResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountAssetResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "optNextAssetId",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void AccountAssetResponse_ClearOptNextAssetIdOneOfCase(AccountAssetResponse *message) {
  GPBDescriptor *descriptor = [AccountAssetResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - AccountDetailResponse

@implementation AccountDetailResponse

@dynamic detail;
@dynamic totalNumber;
@dynamic hasNextRecordId, nextRecordId;

typedef struct AccountDetailResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *detail;
  AccountDetailRecordId *nextRecordId;
  uint64_t totalNumber;
} AccountDetailResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "detail",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountDetailResponse_FieldNumber_Detail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountDetailResponse__storage_, detail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountDetailResponse_FieldNumber_TotalNumber,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountDetailResponse__storage_, totalNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nextRecordId",
        .dataTypeSpecific.clazz = GPBObjCClass(AccountDetailRecordId),
        .number = AccountDetailResponse_FieldNumber_NextRecordId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccountDetailResponse__storage_, nextRecordId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountDetailResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountDetailResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountResponse

@implementation AccountResponse

@dynamic hasAccount, account;
@dynamic accountRolesArray, accountRolesArray_Count;

typedef struct AccountResponse__storage_ {
  uint32_t _has_storage_[1];
  Account *account;
  NSMutableArray *accountRolesArray;
} AccountResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.clazz = GPBObjCClass(Account),
        .number = AccountResponse_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountResponse__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountRolesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountResponse_FieldNumber_AccountRolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccountResponse__storage_, accountRolesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AssetResponse

@implementation AssetResponse

@dynamic hasAsset, asset;

typedef struct AssetResponse__storage_ {
  uint32_t _has_storage_[1];
  Asset *asset;
} AssetResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "asset",
        .dataTypeSpecific.clazz = GPBObjCClass(Asset),
        .number = AssetResponse_FieldNumber_Asset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssetResponse__storage_, asset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssetResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RolesResponse

@implementation RolesResponse

@dynamic rolesArray, rolesArray_Count;

typedef struct RolesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rolesArray;
} RolesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rolesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RolesResponse_FieldNumber_RolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RolesResponse__storage_, rolesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RolesResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RolesResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RolePermissionsResponse

@implementation RolePermissionsResponse

@dynamic permissionsArray, permissionsArray_Count;

typedef struct RolePermissionsResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *permissionsArray;
} RolePermissionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "permissionsArray",
        .dataTypeSpecific.enumDescFunc = RolePermission_EnumDescriptor,
        .number = RolePermissionsResponse_FieldNumber_PermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RolePermissionsResponse__storage_, permissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RolePermissionsResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RolePermissionsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ErrorResponse

@implementation ErrorResponse

@dynamic reason;
@dynamic message;
@dynamic errorCode;

typedef struct ErrorResponse__storage_ {
  uint32_t _has_storage_[1];
  ErrorResponse_Reason reason;
  uint32_t errorCode;
  NSString *message;
} ErrorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = ErrorResponse_Reason_EnumDescriptor,
        .number = ErrorResponse_FieldNumber_Reason,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ErrorResponse__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = ErrorResponse_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ErrorResponse__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = ErrorResponse_FieldNumber_ErrorCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ErrorResponse__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ErrorResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ErrorResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ErrorResponse_Reason_RawValue(ErrorResponse *message) {
  GPBDescriptor *descriptor = [ErrorResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ErrorResponse_FieldNumber_Reason];
  return GPBGetMessageRawEnumField(message, field);
}

void SetErrorResponse_Reason_RawValue(ErrorResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ErrorResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ErrorResponse_FieldNumber_Reason];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum ErrorResponse_Reason

GPBEnumDescriptor *ErrorResponse_Reason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StatelessInvalid\000StatefulInvalid\000NoAccou"
        "nt\000NoAccountAssets\000NoAccountDetail\000NoSig"
        "natories\000NotSupported\000NoAsset\000NoRoles\000";
    static const int32_t values[] = {
        ErrorResponse_Reason_StatelessInvalid,
        ErrorResponse_Reason_StatefulInvalid,
        ErrorResponse_Reason_NoAccount,
        ErrorResponse_Reason_NoAccountAssets,
        ErrorResponse_Reason_NoAccountDetail,
        ErrorResponse_Reason_NoSignatories,
        ErrorResponse_Reason_NotSupported,
        ErrorResponse_Reason_NoAsset,
        ErrorResponse_Reason_NoRoles,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ErrorResponse_Reason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ErrorResponse_Reason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ErrorResponse_Reason_IsValidValue(int32_t value__) {
  switch (value__) {
    case ErrorResponse_Reason_StatelessInvalid:
    case ErrorResponse_Reason_StatefulInvalid:
    case ErrorResponse_Reason_NoAccount:
    case ErrorResponse_Reason_NoAccountAssets:
    case ErrorResponse_Reason_NoAccountDetail:
    case ErrorResponse_Reason_NoSignatories:
    case ErrorResponse_Reason_NotSupported:
    case ErrorResponse_Reason_NoAsset:
    case ErrorResponse_Reason_NoRoles:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SignatoriesResponse

@implementation SignatoriesResponse

@dynamic keysArray, keysArray_Count;

typedef struct SignatoriesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keysArray;
} SignatoriesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keysArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SignatoriesResponse_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SignatoriesResponse__storage_, keysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignatoriesResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignatoriesResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionsResponse

@implementation TransactionsResponse

@dynamic transactionsArray, transactionsArray_Count;

typedef struct TransactionsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} TransactionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = TransactionsResponse_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionsResponse__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionsResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionsPageResponse

@implementation TransactionsPageResponse

@dynamic nextPageTagOneOfCase;
@dynamic transactionsArray, transactionsArray_Count;
@dynamic allTransactionsSize;
@dynamic nextTxHash;

typedef struct TransactionsPageResponse__storage_ {
  uint32_t _has_storage_[2];
  uint32_t allTransactionsSize;
  NSMutableArray *transactionsArray;
  NSString *nextTxHash;
} TransactionsPageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = TransactionsPageResponse_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionsPageResponse__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "allTransactionsSize",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionsPageResponse_FieldNumber_AllTransactionsSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionsPageResponse__storage_, allTransactionsSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nextTxHash",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionsPageResponse_FieldNumber_NextTxHash,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TransactionsPageResponse__storage_, nextTxHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionsPageResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionsPageResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "nextPageTag",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TransactionsPageResponse_ClearNextPageTagOneOfCase(TransactionsPageResponse *message) {
  GPBDescriptor *descriptor = [TransactionsPageResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - PendingTransactionsPageResponse

@implementation PendingTransactionsPageResponse

@dynamic transactionsArray, transactionsArray_Count;
@dynamic allTransactionsSize;
@dynamic hasNextBatchInfo, nextBatchInfo;

typedef struct PendingTransactionsPageResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t allTransactionsSize;
  NSMutableArray *transactionsArray;
  PendingTransactionsPageResponse_BatchInfo *nextBatchInfo;
} PendingTransactionsPageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = PendingTransactionsPageResponse_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingTransactionsPageResponse__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "allTransactionsSize",
        .dataTypeSpecific.clazz = Nil,
        .number = PendingTransactionsPageResponse_FieldNumber_AllTransactionsSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingTransactionsPageResponse__storage_, allTransactionsSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nextBatchInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(PendingTransactionsPageResponse_BatchInfo),
        .number = PendingTransactionsPageResponse_FieldNumber_NextBatchInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingTransactionsPageResponse__storage_, nextBatchInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingTransactionsPageResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingTransactionsPageResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingTransactionsPageResponse_BatchInfo

@implementation PendingTransactionsPageResponse_BatchInfo

@dynamic firstTxHash;
@dynamic batchSize;

typedef struct PendingTransactionsPageResponse_BatchInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t batchSize;
  NSString *firstTxHash;
} PendingTransactionsPageResponse_BatchInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "firstTxHash",
        .dataTypeSpecific.clazz = Nil,
        .number = PendingTransactionsPageResponse_BatchInfo_FieldNumber_FirstTxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingTransactionsPageResponse_BatchInfo__storage_, firstTxHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "batchSize",
        .dataTypeSpecific.clazz = Nil,
        .number = PendingTransactionsPageResponse_BatchInfo_FieldNumber_BatchSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingTransactionsPageResponse_BatchInfo__storage_, batchSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingTransactionsPageResponse_BatchInfo class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingTransactionsPageResponse_BatchInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(PendingTransactionsPageResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeersResponse

@implementation PeersResponse

@dynamic peersArray, peersArray_Count;

typedef struct PeersResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} PeersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = PeersResponse_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PeersResponse__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeersResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeersResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EngineReceiptsResponse

@implementation EngineReceiptsResponse

@dynamic engineReceiptsArray, engineReceiptsArray_Count;

typedef struct EngineReceiptsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *engineReceiptsArray;
} EngineReceiptsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "engineReceiptsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(EngineReceipt),
        .number = EngineReceiptsResponse_FieldNumber_EngineReceiptsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EngineReceiptsResponse__storage_, engineReceiptsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EngineReceiptsResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EngineReceiptsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryResponse

@implementation QueryResponse

@dynamic responseOneOfCase;
@dynamic accountAssetsResponse;
@dynamic accountDetailResponse;
@dynamic accountResponse;
@dynamic errorResponse;
@dynamic signatoriesResponse;
@dynamic transactionsResponse;
@dynamic assetResponse;
@dynamic rolesResponse;
@dynamic rolePermissionsResponse;
@dynamic transactionsPageResponse;
@dynamic pendingTransactionsPageResponse;
@dynamic blockResponse;
@dynamic peersResponse;
@dynamic engineReceiptsResponse;
@dynamic queryHash;

typedef struct QueryResponse__storage_ {
  uint32_t _has_storage_[2];
  AccountAssetResponse *accountAssetsResponse;
  AccountDetailResponse *accountDetailResponse;
  AccountResponse *accountResponse;
  ErrorResponse *errorResponse;
  SignatoriesResponse *signatoriesResponse;
  TransactionsResponse *transactionsResponse;
  AssetResponse *assetResponse;
  RolesResponse *rolesResponse;
  RolePermissionsResponse *rolePermissionsResponse;
  NSString *queryHash;
  TransactionsPageResponse *transactionsPageResponse;
  BlockResponse *blockResponse;
  PendingTransactionsPageResponse *pendingTransactionsPageResponse;
  PeersResponse *peersResponse;
  EngineReceiptsResponse *engineReceiptsResponse;
} QueryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountAssetsResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(AccountAssetResponse),
        .number = QueryResponse_FieldNumber_AccountAssetsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, accountAssetsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountDetailResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(AccountDetailResponse),
        .number = QueryResponse_FieldNumber_AccountDetailResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, accountDetailResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(AccountResponse),
        .number = QueryResponse_FieldNumber_AccountResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, accountResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "errorResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(ErrorResponse),
        .number = QueryResponse_FieldNumber_ErrorResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, errorResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signatoriesResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(SignatoriesResponse),
        .number = QueryResponse_FieldNumber_SignatoriesResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, signatoriesResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionsResponse),
        .number = QueryResponse_FieldNumber_TransactionsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, transactionsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "assetResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(AssetResponse),
        .number = QueryResponse_FieldNumber_AssetResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, assetResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rolesResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(RolesResponse),
        .number = QueryResponse_FieldNumber_RolesResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, rolesResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rolePermissionsResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(RolePermissionsResponse),
        .number = QueryResponse_FieldNumber_RolePermissionsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, rolePermissionsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "queryHash",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryResponse_FieldNumber_QueryHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, queryHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transactionsPageResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionsPageResponse),
        .number = QueryResponse_FieldNumber_TransactionsPageResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, transactionsPageResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockResponse),
        .number = QueryResponse_FieldNumber_BlockResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, blockResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingTransactionsPageResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(PendingTransactionsPageResponse),
        .number = QueryResponse_FieldNumber_PendingTransactionsPageResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, pendingTransactionsPageResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peersResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(PeersResponse),
        .number = QueryResponse_FieldNumber_PeersResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, peersResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "engineReceiptsResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(EngineReceiptsResponse),
        .number = QueryResponse_FieldNumber_EngineReceiptsResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QueryResponse__storage_, engineReceiptsResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "response",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void QueryResponse_ClearResponseOneOfCase(QueryResponse *message) {
  GPBDescriptor *descriptor = [QueryResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - BlockResponse

@implementation BlockResponse

@dynamic hasBlock, block;

typedef struct BlockResponse__storage_ {
  uint32_t _has_storage_[1];
  Block *block;
} BlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.clazz = GPBObjCClass(Block),
        .number = BlockResponse_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockResponse__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockErrorResponse

@implementation BlockErrorResponse

@dynamic message;

typedef struct BlockErrorResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} BlockErrorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockErrorResponse_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockErrorResponse__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockErrorResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockErrorResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockQueryResponse

@implementation BlockQueryResponse

@dynamic responseOneOfCase;
@dynamic blockResponse;
@dynamic blockErrorResponse;

typedef struct BlockQueryResponse__storage_ {
  uint32_t _has_storage_[2];
  BlockResponse *blockResponse;
  BlockErrorResponse *blockErrorResponse;
} BlockQueryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockResponse),
        .number = BlockQueryResponse_FieldNumber_BlockResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BlockQueryResponse__storage_, blockResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockErrorResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockErrorResponse),
        .number = BlockQueryResponse_FieldNumber_BlockErrorResponse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BlockQueryResponse__storage_, blockErrorResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockQueryResponse class]
                                     rootClass:[QryResponsesRoot class]
                                          file:QryResponsesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockQueryResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "response",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void BlockQueryResponse_ClearResponseOneOfCase(BlockQueryResponse *message) {
  GPBDescriptor *descriptor = [BlockQueryResponse descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
