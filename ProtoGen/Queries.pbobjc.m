// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: queries.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Queries.pbobjc.h"
#import "Primitive.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AccountDetailPaginationMeta);
GPBObjCClassDeclaration(AccountDetailRecordId);
GPBObjCClassDeclaration(AssetPaginationMeta);
GPBObjCClassDeclaration(GetAccount);
GPBObjCClassDeclaration(GetAccountAssetTransactions);
GPBObjCClassDeclaration(GetAccountAssets);
GPBObjCClassDeclaration(GetAccountDetail);
GPBObjCClassDeclaration(GetAccountTransactions);
GPBObjCClassDeclaration(GetAssetInfo);
GPBObjCClassDeclaration(GetBlock);
GPBObjCClassDeclaration(GetEngineReceipts);
GPBObjCClassDeclaration(GetPeers);
GPBObjCClassDeclaration(GetPendingTransactions);
GPBObjCClassDeclaration(GetRolePermissions);
GPBObjCClassDeclaration(GetRoles);
GPBObjCClassDeclaration(GetSignatories);
GPBObjCClassDeclaration(GetTransactions);
GPBObjCClassDeclaration(Ordering);
GPBObjCClassDeclaration(Ordering_FieldOrdering);
GPBObjCClassDeclaration(Query);
GPBObjCClassDeclaration(QueryPayloadMeta);
GPBObjCClassDeclaration(Query_Payload);
GPBObjCClassDeclaration(Signature);
GPBObjCClassDeclaration(TxPaginationMeta);

#pragma mark - QueriesRoot

@implementation QueriesRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - QueriesRoot_FileDescriptor

static GPBFileDescriptor *QueriesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"iroha.protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Field

GPBEnumDescriptor *Field_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "KCreatedTime\000KPosition\000";
    static const int32_t values[] = {
        Field_KCreatedTime,
        Field_KPosition,
    };
    static const char *extraTextFormatInfo = "\002\000,\000\001)\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Field)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Field_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Field_IsValidValue(int32_t value__) {
  switch (value__) {
    case Field_KCreatedTime:
    case Field_KPosition:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Direction

GPBEnumDescriptor *Direction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "KAscending\000KDescending\000";
    static const int32_t values[] = {
        Direction_KAscending,
        Direction_KDescending,
    };
    static const char *extraTextFormatInfo = "\002\000*\000\001+\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Direction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Direction_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Direction_IsValidValue(int32_t value__) {
  switch (value__) {
    case Direction_KAscending:
    case Direction_KDescending:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Ordering

@implementation Ordering

@dynamic sequenceArray, sequenceArray_Count;

typedef struct Ordering__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *sequenceArray;
} Ordering__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sequenceArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Ordering_FieldOrdering),
        .number = Ordering_FieldNumber_SequenceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Ordering__storage_, sequenceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Ordering class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Ordering__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Ordering_FieldOrdering

@implementation Ordering_FieldOrdering

@dynamic field;
@dynamic direction;

typedef struct Ordering_FieldOrdering__storage_ {
  uint32_t _has_storage_[1];
  Field field;
  Direction direction;
} Ordering_FieldOrdering__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "field",
        .dataTypeSpecific.enumDescFunc = Field_EnumDescriptor,
        .number = Ordering_FieldOrdering_FieldNumber_Field,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Ordering_FieldOrdering__storage_, field),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "direction",
        .dataTypeSpecific.enumDescFunc = Direction_EnumDescriptor,
        .number = Ordering_FieldOrdering_FieldNumber_Direction,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Ordering_FieldOrdering__storage_, direction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Ordering_FieldOrdering class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Ordering_FieldOrdering__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Ordering)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Ordering_FieldOrdering_Field_RawValue(Ordering_FieldOrdering *message) {
  GPBDescriptor *descriptor = [Ordering_FieldOrdering descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Ordering_FieldOrdering_FieldNumber_Field];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOrdering_FieldOrdering_Field_RawValue(Ordering_FieldOrdering *message, int32_t value) {
  GPBDescriptor *descriptor = [Ordering_FieldOrdering descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Ordering_FieldOrdering_FieldNumber_Field];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t Ordering_FieldOrdering_Direction_RawValue(Ordering_FieldOrdering *message) {
  GPBDescriptor *descriptor = [Ordering_FieldOrdering descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Ordering_FieldOrdering_FieldNumber_Direction];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOrdering_FieldOrdering_Direction_RawValue(Ordering_FieldOrdering *message, int32_t value) {
  GPBDescriptor *descriptor = [Ordering_FieldOrdering descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Ordering_FieldOrdering_FieldNumber_Direction];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - TxPaginationMeta

@implementation TxPaginationMeta

@dynamic optFirstTxHashOneOfCase;
@dynamic pageSize;
@dynamic firstTxHash;
@dynamic hasOrdering, ordering;

typedef struct TxPaginationMeta__storage_ {
  uint32_t _has_storage_[2];
  uint32_t pageSize;
  NSString *firstTxHash;
  Ordering *ordering;
} TxPaginationMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageSize",
        .dataTypeSpecific.clazz = Nil,
        .number = TxPaginationMeta_FieldNumber_PageSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxPaginationMeta__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "firstTxHash",
        .dataTypeSpecific.clazz = Nil,
        .number = TxPaginationMeta_FieldNumber_FirstTxHash,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TxPaginationMeta__storage_, firstTxHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ordering",
        .dataTypeSpecific.clazz = GPBObjCClass(Ordering),
        .number = TxPaginationMeta_FieldNumber_Ordering,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxPaginationMeta__storage_, ordering),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TxPaginationMeta class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxPaginationMeta__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "optFirstTxHash",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TxPaginationMeta_ClearOptFirstTxHashOneOfCase(TxPaginationMeta *message) {
  GPBDescriptor *descriptor = [TxPaginationMeta descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - AssetPaginationMeta

@implementation AssetPaginationMeta

@dynamic optFirstAssetIdOneOfCase;
@dynamic pageSize;
@dynamic firstAssetId;

typedef struct AssetPaginationMeta__storage_ {
  uint32_t _has_storage_[2];
  uint32_t pageSize;
  NSString *firstAssetId;
} AssetPaginationMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageSize",
        .dataTypeSpecific.clazz = Nil,
        .number = AssetPaginationMeta_FieldNumber_PageSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssetPaginationMeta__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "firstAssetId",
        .dataTypeSpecific.clazz = Nil,
        .number = AssetPaginationMeta_FieldNumber_FirstAssetId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AssetPaginationMeta__storage_, firstAssetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AssetPaginationMeta class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssetPaginationMeta__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "optFirstAssetId",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void AssetPaginationMeta_ClearOptFirstAssetIdOneOfCase(AssetPaginationMeta *message) {
  GPBDescriptor *descriptor = [AssetPaginationMeta descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetAccount

@implementation GetAccount

@dynamic accountId;

typedef struct GetAccount__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
} GetAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAccount_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccount__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccount class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlock

@implementation GetBlock

@dynamic height;

typedef struct GetBlock__storage_ {
  uint32_t _has_storage_[1];
  uint64_t height;
} GetBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlock_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlock__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlock class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlock__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetSignatories

@implementation GetSignatories

@dynamic accountId;

typedef struct GetSignatories__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
} GetSignatories__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetSignatories_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetSignatories__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetSignatories class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetSignatories__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountTransactions

@implementation GetAccountTransactions

@dynamic accountId;
@dynamic hasPaginationMeta, paginationMeta;

typedef struct GetAccountTransactions__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  TxPaginationMeta *paginationMeta;
} GetAccountTransactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAccountTransactions_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountTransactions__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paginationMeta",
        .dataTypeSpecific.clazz = GPBObjCClass(TxPaginationMeta),
        .number = GetAccountTransactions_FieldNumber_PaginationMeta,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAccountTransactions__storage_, paginationMeta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountTransactions class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountTransactions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountAssetTransactions

@implementation GetAccountAssetTransactions

@dynamic accountId;
@dynamic assetId;
@dynamic hasPaginationMeta, paginationMeta;

typedef struct GetAccountAssetTransactions__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *assetId;
  TxPaginationMeta *paginationMeta;
} GetAccountAssetTransactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAccountAssetTransactions_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountAssetTransactions__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAccountAssetTransactions_FieldNumber_AssetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAccountAssetTransactions__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paginationMeta",
        .dataTypeSpecific.clazz = GPBObjCClass(TxPaginationMeta),
        .number = GetAccountAssetTransactions_FieldNumber_PaginationMeta,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetAccountAssetTransactions__storage_, paginationMeta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountAssetTransactions class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountAssetTransactions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTransactions

@implementation GetTransactions

@dynamic txHashesArray, txHashesArray_Count;

typedef struct GetTransactions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txHashesArray;
} GetTransactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txHashesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetTransactions_FieldNumber_TxHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTransactions__storage_, txHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTransactions class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTransactions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountAssets

@implementation GetAccountAssets

@dynamic accountId;
@dynamic hasPaginationMeta, paginationMeta;

typedef struct GetAccountAssets__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  AssetPaginationMeta *paginationMeta;
} GetAccountAssets__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAccountAssets_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountAssets__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paginationMeta",
        .dataTypeSpecific.clazz = GPBObjCClass(AssetPaginationMeta),
        .number = GetAccountAssets_FieldNumber_PaginationMeta,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAccountAssets__storage_, paginationMeta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountAssets class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountAssets__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountDetailPaginationMeta

@implementation AccountDetailPaginationMeta

@dynamic pageSize;
@dynamic hasFirstRecordId, firstRecordId;

typedef struct AccountDetailPaginationMeta__storage_ {
  uint32_t _has_storage_[1];
  uint32_t pageSize;
  AccountDetailRecordId *firstRecordId;
} AccountDetailPaginationMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageSize",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountDetailPaginationMeta_FieldNumber_PageSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountDetailPaginationMeta__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "firstRecordId",
        .dataTypeSpecific.clazz = GPBObjCClass(AccountDetailRecordId),
        .number = AccountDetailPaginationMeta_FieldNumber_FirstRecordId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountDetailPaginationMeta__storage_, firstRecordId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountDetailPaginationMeta class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountDetailPaginationMeta__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAccountDetail

@implementation GetAccountDetail

@dynamic optAccountIdOneOfCase;
@dynamic optKeyOneOfCase;
@dynamic optWriterOneOfCase;
@dynamic accountId;
@dynamic key;
@dynamic writer;
@dynamic hasPaginationMeta, paginationMeta;

typedef struct GetAccountDetail__storage_ {
  uint32_t _has_storage_[4];
  NSString *accountId;
  NSString *key;
  NSString *writer;
  AccountDetailPaginationMeta *paginationMeta;
} GetAccountDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAccountDetail_FieldNumber_AccountId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetAccountDetail__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAccountDetail_FieldNumber_Key,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(GetAccountDetail__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "writer",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAccountDetail_FieldNumber_Writer,
        .hasIndex = -3,
        .offset = (uint32_t)offsetof(GetAccountDetail__storage_, writer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paginationMeta",
        .dataTypeSpecific.clazz = GPBObjCClass(AccountDetailPaginationMeta),
        .number = GetAccountDetail_FieldNumber_PaginationMeta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAccountDetail__storage_, paginationMeta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAccountDetail class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAccountDetail__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "optAccountId",
      "optKey",
      "optWriter",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetAccountDetail_ClearOptAccountIdOneOfCase(GetAccountDetail *message) {
  GPBDescriptor *descriptor = [GetAccountDetail descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
void GetAccountDetail_ClearOptKeyOneOfCase(GetAccountDetail *message) {
  GPBDescriptor *descriptor = [GetAccountDetail descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:1];
  GPBClearOneof(message, oneof);
}
void GetAccountDetail_ClearOptWriterOneOfCase(GetAccountDetail *message) {
  GPBDescriptor *descriptor = [GetAccountDetail descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:2];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetAssetInfo

@implementation GetAssetInfo

@dynamic assetId;

typedef struct GetAssetInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *assetId;
} GetAssetInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAssetInfo_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAssetInfo__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAssetInfo class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAssetInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRoles

@implementation GetRoles


typedef struct GetRoles__storage_ {
  uint32_t _has_storage_[1];
} GetRoles__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRoles class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetRoles__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRolePermissions

@implementation GetRolePermissions

@dynamic roleId;

typedef struct GetRolePermissions__storage_ {
  uint32_t _has_storage_[1];
  NSString *roleId;
} GetRolePermissions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roleId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRolePermissions_FieldNumber_RoleId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRolePermissions__storage_, roleId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRolePermissions class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRolePermissions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPendingTransactions

@implementation GetPendingTransactions

@dynamic hasPaginationMeta, paginationMeta;

typedef struct GetPendingTransactions__storage_ {
  uint32_t _has_storage_[1];
  TxPaginationMeta *paginationMeta;
} GetPendingTransactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paginationMeta",
        .dataTypeSpecific.clazz = GPBObjCClass(TxPaginationMeta),
        .number = GetPendingTransactions_FieldNumber_PaginationMeta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPendingTransactions__storage_, paginationMeta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPendingTransactions class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPendingTransactions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeers

@implementation GetPeers


typedef struct GetPeers__storage_ {
  uint32_t _has_storage_[1];
} GetPeers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeers class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetPeers__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryPayloadMeta

@implementation QueryPayloadMeta

@dynamic createdTime;
@dynamic creatorAccountId;
@dynamic queryCounter;

typedef struct QueryPayloadMeta__storage_ {
  uint32_t _has_storage_[1];
  NSString *creatorAccountId;
  uint64_t createdTime;
  uint64_t queryCounter;
} QueryPayloadMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "createdTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryPayloadMeta_FieldNumber_CreatedTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryPayloadMeta__storage_, createdTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "creatorAccountId",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryPayloadMeta_FieldNumber_CreatorAccountId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QueryPayloadMeta__storage_, creatorAccountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "queryCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryPayloadMeta_FieldNumber_QueryCounter,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QueryPayloadMeta__storage_, queryCounter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryPayloadMeta class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryPayloadMeta__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEngineReceipts

@implementation GetEngineReceipts

@dynamic txHash;

typedef struct GetEngineReceipts__storage_ {
  uint32_t _has_storage_[1];
  NSString *txHash;
} GetEngineReceipts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEngineReceipts_FieldNumber_TxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEngineReceipts__storage_, txHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEngineReceipts class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEngineReceipts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Query

@implementation Query

@dynamic hasPayload, payload;
@dynamic hasSignature, signature;

typedef struct Query__storage_ {
  uint32_t _has_storage_[1];
  Query_Payload *payload;
  Signature *signature;
} Query__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payload",
        .dataTypeSpecific.clazz = GPBObjCClass(Query_Payload),
        .number = Query_FieldNumber_Payload,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Query__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = GPBObjCClass(Signature),
        .number = Query_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Query__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Query class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Query__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Query_Payload

@implementation Query_Payload

@dynamic queryOneOfCase;
@dynamic hasMeta, meta;
@dynamic getAccount;
@dynamic getSignatories;
@dynamic getAccountTransactions;
@dynamic getAccountAssetTransactions;
@dynamic getTransactions;
@dynamic getAccountAssets;
@dynamic getAccountDetail;
@dynamic getRoles;
@dynamic getRolePermissions;
@dynamic getAssetInfo;
@dynamic getPendingTransactions;
@dynamic getBlock;
@dynamic getPeers;
@dynamic getEngineReceipts;

typedef struct Query_Payload__storage_ {
  uint32_t _has_storage_[2];
  QueryPayloadMeta *meta;
  GetAccount *getAccount;
  GetSignatories *getSignatories;
  GetAccountTransactions *getAccountTransactions;
  GetAccountAssetTransactions *getAccountAssetTransactions;
  GetTransactions *getTransactions;
  GetAccountAssets *getAccountAssets;
  GetAccountDetail *getAccountDetail;
  GetRoles *getRoles;
  GetRolePermissions *getRolePermissions;
  GetAssetInfo *getAssetInfo;
  GetPendingTransactions *getPendingTransactions;
  GetBlock *getBlock;
  GetPeers *getPeers;
  GetEngineReceipts *getEngineReceipts;
} Query_Payload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meta",
        .dataTypeSpecific.clazz = GPBObjCClass(QueryPayloadMeta),
        .number = Query_Payload_FieldNumber_Meta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, meta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getAccount",
        .dataTypeSpecific.clazz = GPBObjCClass(GetAccount),
        .number = Query_Payload_FieldNumber_GetAccount,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getAccount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getSignatories",
        .dataTypeSpecific.clazz = GPBObjCClass(GetSignatories),
        .number = Query_Payload_FieldNumber_GetSignatories,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getSignatories),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getAccountTransactions",
        .dataTypeSpecific.clazz = GPBObjCClass(GetAccountTransactions),
        .number = Query_Payload_FieldNumber_GetAccountTransactions,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getAccountTransactions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getAccountAssetTransactions",
        .dataTypeSpecific.clazz = GPBObjCClass(GetAccountAssetTransactions),
        .number = Query_Payload_FieldNumber_GetAccountAssetTransactions,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getAccountAssetTransactions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getTransactions",
        .dataTypeSpecific.clazz = GPBObjCClass(GetTransactions),
        .number = Query_Payload_FieldNumber_GetTransactions,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getTransactions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getAccountAssets",
        .dataTypeSpecific.clazz = GPBObjCClass(GetAccountAssets),
        .number = Query_Payload_FieldNumber_GetAccountAssets,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getAccountAssets),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getAccountDetail",
        .dataTypeSpecific.clazz = GPBObjCClass(GetAccountDetail),
        .number = Query_Payload_FieldNumber_GetAccountDetail,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getAccountDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getRoles",
        .dataTypeSpecific.clazz = GPBObjCClass(GetRoles),
        .number = Query_Payload_FieldNumber_GetRoles,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getRoles),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getRolePermissions",
        .dataTypeSpecific.clazz = GPBObjCClass(GetRolePermissions),
        .number = Query_Payload_FieldNumber_GetRolePermissions,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getRolePermissions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getAssetInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(GetAssetInfo),
        .number = Query_Payload_FieldNumber_GetAssetInfo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getAssetInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPendingTransactions",
        .dataTypeSpecific.clazz = GPBObjCClass(GetPendingTransactions),
        .number = Query_Payload_FieldNumber_GetPendingTransactions,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getPendingTransactions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getBlock",
        .dataTypeSpecific.clazz = GPBObjCClass(GetBlock),
        .number = Query_Payload_FieldNumber_GetBlock,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getBlock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getPeers",
        .dataTypeSpecific.clazz = GPBObjCClass(GetPeers),
        .number = Query_Payload_FieldNumber_GetPeers,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getPeers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getEngineReceipts",
        .dataTypeSpecific.clazz = GPBObjCClass(GetEngineReceipts),
        .number = Query_Payload_FieldNumber_GetEngineReceipts,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Query_Payload__storage_, getEngineReceipts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Query_Payload class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Query_Payload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "query",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Query)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Query_Payload_ClearQueryOneOfCase(Query_Payload *message) {
  GPBDescriptor *descriptor = [Query_Payload descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - BlocksQuery

@implementation BlocksQuery

@dynamic hasMeta, meta;
@dynamic hasSignature, signature;

typedef struct BlocksQuery__storage_ {
  uint32_t _has_storage_[1];
  QueryPayloadMeta *meta;
  Signature *signature;
} BlocksQuery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meta",
        .dataTypeSpecific.clazz = GPBObjCClass(QueryPayloadMeta),
        .number = BlocksQuery_FieldNumber_Meta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlocksQuery__storage_, meta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = GPBObjCClass(Signature),
        .number = BlocksQuery_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlocksQuery__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlocksQuery class]
                                     rootClass:[QueriesRoot class]
                                          file:QueriesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlocksQuery__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
