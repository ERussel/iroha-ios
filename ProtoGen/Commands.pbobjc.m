// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commands.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Commands.pbobjc.h"
#import "Primitive.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AddAssetQuantity);
GPBObjCClassDeclaration(AddPeer);
GPBObjCClassDeclaration(AddSignatory);
GPBObjCClassDeclaration(AppendRole);
GPBObjCClassDeclaration(CallEngine);
GPBObjCClassDeclaration(CompareAndSetAccountDetail);
GPBObjCClassDeclaration(CreateAccount);
GPBObjCClassDeclaration(CreateAsset);
GPBObjCClassDeclaration(CreateDomain);
GPBObjCClassDeclaration(CreateRole);
GPBObjCClassDeclaration(DetachRole);
GPBObjCClassDeclaration(GrantPermission);
GPBObjCClassDeclaration(Peer);
GPBObjCClassDeclaration(RemovePeer);
GPBObjCClassDeclaration(RemoveSignatory);
GPBObjCClassDeclaration(RevokePermission);
GPBObjCClassDeclaration(SetAccountDetail);
GPBObjCClassDeclaration(SetAccountQuorum);
GPBObjCClassDeclaration(SetSettingValue);
GPBObjCClassDeclaration(SubtractAssetQuantity);
GPBObjCClassDeclaration(TransferAsset);

#pragma mark - CommandsRoot

@implementation CommandsRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - CommandsRoot_FileDescriptor

static GPBFileDescriptor *CommandsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"iroha.protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - AddAssetQuantity

@implementation AddAssetQuantity

@dynamic assetId;
@dynamic amount;

typedef struct AddAssetQuantity__storage_ {
  uint32_t _has_storage_[1];
  NSString *assetId;
  NSString *amount;
} AddAssetQuantity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = AddAssetQuantity_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddAssetQuantity__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = AddAssetQuantity_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddAssetQuantity__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddAssetQuantity class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddAssetQuantity__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddPeer

@implementation AddPeer

@dynamic hasPeer, peer;

typedef struct AddPeer__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
} AddPeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = AddPeer_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddPeer__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddPeer class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddPeer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemovePeer

@implementation RemovePeer

@dynamic publicKey;

typedef struct RemovePeer__storage_ {
  uint32_t _has_storage_[1];
  NSString *publicKey;
} RemovePeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.clazz = Nil,
        .number = RemovePeer_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemovePeer__storage_, publicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemovePeer class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemovePeer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddSignatory

@implementation AddSignatory

@dynamic accountId;
@dynamic publicKey;

typedef struct AddSignatory__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *publicKey;
} AddSignatory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = AddSignatory_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddSignatory__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.clazz = Nil,
        .number = AddSignatory_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddSignatory__storage_, publicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddSignatory class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddSignatory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateAsset

@implementation CreateAsset

@dynamic assetName;
@dynamic domainId;
@dynamic precision;

typedef struct CreateAsset__storage_ {
  uint32_t _has_storage_[1];
  uint32_t precision;
  NSString *assetName;
  NSString *domainId;
} CreateAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetName",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateAsset_FieldNumber_AssetName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateAsset__storage_, assetName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domainId",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateAsset_FieldNumber_DomainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateAsset__storage_, domainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "precision",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateAsset_FieldNumber_Precision,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CreateAsset__storage_, precision),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateAsset class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateAsset__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateAccount

@implementation CreateAccount

@dynamic accountName;
@dynamic domainId;
@dynamic publicKey;

typedef struct CreateAccount__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountName;
  NSString *domainId;
  NSString *publicKey;
} CreateAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateAccount_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateAccount__storage_, accountName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domainId",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateAccount_FieldNumber_DomainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateAccount__storage_, domainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateAccount_FieldNumber_PublicKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CreateAccount__storage_, publicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateAccount class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateAccount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetAccountDetail

@implementation SetAccountDetail

@dynamic accountId;
@dynamic key;
@dynamic value;

typedef struct SetAccountDetail__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *key;
  NSString *value;
} SetAccountDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = SetAccountDetail_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetAccountDetail__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = SetAccountDetail_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetAccountDetail__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = SetAccountDetail_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SetAccountDetail__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetAccountDetail class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetAccountDetail__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateDomain

@implementation CreateDomain

@dynamic domainId;
@dynamic defaultRole;

typedef struct CreateDomain__storage_ {
  uint32_t _has_storage_[1];
  NSString *domainId;
  NSString *defaultRole;
} CreateDomain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "domainId",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateDomain_FieldNumber_DomainId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateDomain__storage_, domainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "defaultRole",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateDomain_FieldNumber_DefaultRole,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateDomain__storage_, defaultRole),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateDomain class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateDomain__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveSignatory

@implementation RemoveSignatory

@dynamic accountId;
@dynamic publicKey;

typedef struct RemoveSignatory__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *publicKey;
} RemoveSignatory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoveSignatory_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveSignatory__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoveSignatory_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemoveSignatory__storage_, publicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveSignatory class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveSignatory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetAccountQuorum

@implementation SetAccountQuorum

@dynamic accountId;
@dynamic quorum;

typedef struct SetAccountQuorum__storage_ {
  uint32_t _has_storage_[1];
  uint32_t quorum;
  NSString *accountId;
} SetAccountQuorum__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = SetAccountQuorum_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetAccountQuorum__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quorum",
        .dataTypeSpecific.clazz = Nil,
        .number = SetAccountQuorum_FieldNumber_Quorum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetAccountQuorum__storage_, quorum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetAccountQuorum class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetAccountQuorum__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferAsset

@implementation TransferAsset

@dynamic srcAccountId;
@dynamic destAccountId;
@dynamic assetId;
@dynamic description_p;
@dynamic amount;

typedef struct TransferAsset__storage_ {
  uint32_t _has_storage_[1];
  NSString *srcAccountId;
  NSString *destAccountId;
  NSString *assetId;
  NSString *description_p;
  NSString *amount;
} TransferAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "srcAccountId",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferAsset_FieldNumber_SrcAccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, srcAccountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "destAccountId",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferAsset_FieldNumber_DestAccountId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, destAccountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferAsset_FieldNumber_AssetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferAsset_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = TransferAsset_FieldNumber_Amount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransferAsset__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferAsset class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferAsset__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppendRole

@implementation AppendRole

@dynamic accountId;
@dynamic roleName;

typedef struct AppendRole__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *roleName;
} AppendRole__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = AppendRole_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppendRole__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roleName",
        .dataTypeSpecific.clazz = Nil,
        .number = AppendRole_FieldNumber_RoleName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppendRole__storage_, roleName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppendRole class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppendRole__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetachRole

@implementation DetachRole

@dynamic accountId;
@dynamic roleName;

typedef struct DetachRole__storage_ {
  uint32_t _has_storage_[1];
  NSString *accountId;
  NSString *roleName;
} DetachRole__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = DetachRole_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetachRole__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roleName",
        .dataTypeSpecific.clazz = Nil,
        .number = DetachRole_FieldNumber_RoleName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DetachRole__storage_, roleName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetachRole class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetachRole__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateRole

@implementation CreateRole

@dynamic roleName;
@dynamic permissionsArray, permissionsArray_Count;

typedef struct CreateRole__storage_ {
  uint32_t _has_storage_[1];
  NSString *roleName;
  GPBEnumArray *permissionsArray;
} CreateRole__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "roleName",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateRole_FieldNumber_RoleName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateRole__storage_, roleName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permissionsArray",
        .dataTypeSpecific.enumDescFunc = RolePermission_EnumDescriptor,
        .number = CreateRole_FieldNumber_PermissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CreateRole__storage_, permissionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateRole class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateRole__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GrantPermission

@implementation GrantPermission

@dynamic accountId;
@dynamic permission;

typedef struct GrantPermission__storage_ {
  uint32_t _has_storage_[1];
  GrantablePermission permission;
  NSString *accountId;
} GrantPermission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = GrantPermission_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GrantPermission__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permission",
        .dataTypeSpecific.enumDescFunc = GrantablePermission_EnumDescriptor,
        .number = GrantPermission_FieldNumber_Permission,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GrantPermission__storage_, permission),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GrantPermission class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GrantPermission__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GrantPermission_Permission_RawValue(GrantPermission *message) {
  GPBDescriptor *descriptor = [GrantPermission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GrantPermission_FieldNumber_Permission];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGrantPermission_Permission_RawValue(GrantPermission *message, int32_t value) {
  GPBDescriptor *descriptor = [GrantPermission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GrantPermission_FieldNumber_Permission];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RevokePermission

@implementation RevokePermission

@dynamic accountId;
@dynamic permission;

typedef struct RevokePermission__storage_ {
  uint32_t _has_storage_[1];
  GrantablePermission permission;
  NSString *accountId;
} RevokePermission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = RevokePermission_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RevokePermission__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "permission",
        .dataTypeSpecific.enumDescFunc = GrantablePermission_EnumDescriptor,
        .number = RevokePermission_FieldNumber_Permission,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RevokePermission__storage_, permission),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RevokePermission class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RevokePermission__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RevokePermission_Permission_RawValue(RevokePermission *message) {
  GPBDescriptor *descriptor = [RevokePermission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RevokePermission_FieldNumber_Permission];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRevokePermission_Permission_RawValue(RevokePermission *message, int32_t value) {
  GPBDescriptor *descriptor = [RevokePermission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RevokePermission_FieldNumber_Permission];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SubtractAssetQuantity

@implementation SubtractAssetQuantity

@dynamic assetId;
@dynamic amount;

typedef struct SubtractAssetQuantity__storage_ {
  uint32_t _has_storage_[1];
  NSString *assetId;
  NSString *amount;
} SubtractAssetQuantity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetId",
        .dataTypeSpecific.clazz = Nil,
        .number = SubtractAssetQuantity_FieldNumber_AssetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SubtractAssetQuantity__storage_, assetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = SubtractAssetQuantity_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SubtractAssetQuantity__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SubtractAssetQuantity class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SubtractAssetQuantity__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CompareAndSetAccountDetail

@implementation CompareAndSetAccountDetail

@dynamic optOldValueOneOfCase;
@dynamic accountId;
@dynamic key;
@dynamic value;
@dynamic oldValue;
@dynamic checkEmpty;

typedef struct CompareAndSetAccountDetail__storage_ {
  uint32_t _has_storage_[2];
  NSString *accountId;
  NSString *key;
  NSString *value;
  NSString *oldValue;
} CompareAndSetAccountDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountId",
        .dataTypeSpecific.clazz = Nil,
        .number = CompareAndSetAccountDetail_FieldNumber_AccountId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CompareAndSetAccountDetail__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = CompareAndSetAccountDetail_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CompareAndSetAccountDetail__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = CompareAndSetAccountDetail_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CompareAndSetAccountDetail__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oldValue",
        .dataTypeSpecific.clazz = Nil,
        .number = CompareAndSetAccountDetail_FieldNumber_OldValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CompareAndSetAccountDetail__storage_, oldValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checkEmpty",
        .dataTypeSpecific.clazz = Nil,
        .number = CompareAndSetAccountDetail_FieldNumber_CheckEmpty,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CompareAndSetAccountDetail class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CompareAndSetAccountDetail__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "optOldValue",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void CompareAndSetAccountDetail_ClearOptOldValueOneOfCase(CompareAndSetAccountDetail *message) {
  GPBDescriptor *descriptor = [CompareAndSetAccountDetail descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SetSettingValue

@implementation SetSettingValue

@dynamic key;
@dynamic value;

typedef struct SetSettingValue__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} SetSettingValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = SetSettingValue_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetSettingValue__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = SetSettingValue_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetSettingValue__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetSettingValue class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetSettingValue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CallEngine

@implementation CallEngine

@dynamic optCalleeOneOfCase;
@dynamic type;
@dynamic caller;
@dynamic callee;
@dynamic input;

typedef struct CallEngine__storage_ {
  uint32_t _has_storage_[2];
  CallEngine_EngineType type;
  NSString *caller;
  NSString *callee;
  NSString *input;
} CallEngine__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = CallEngine_EngineType_EnumDescriptor,
        .number = CallEngine_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CallEngine__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "caller",
        .dataTypeSpecific.clazz = Nil,
        .number = CallEngine_FieldNumber_Caller,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CallEngine__storage_, caller),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "callee",
        .dataTypeSpecific.clazz = Nil,
        .number = CallEngine_FieldNumber_Callee,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CallEngine__storage_, callee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "input",
        .dataTypeSpecific.clazz = Nil,
        .number = CallEngine_FieldNumber_Input,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CallEngine__storage_, input),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CallEngine class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CallEngine__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "optCallee",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CallEngine_Type_RawValue(CallEngine *message) {
  GPBDescriptor *descriptor = [CallEngine descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CallEngine_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetCallEngine_Type_RawValue(CallEngine *message, int32_t value) {
  GPBDescriptor *descriptor = [CallEngine descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CallEngine_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

void CallEngine_ClearOptCalleeOneOfCase(CallEngine *message) {
  GPBDescriptor *descriptor = [CallEngine descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum CallEngine_EngineType

GPBEnumDescriptor *CallEngine_EngineType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "KSolidity\000";
    static const int32_t values[] = {
        CallEngine_EngineType_KSolidity,
    };
    static const char *extraTextFormatInfo = "\001\000)\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CallEngine_EngineType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CallEngine_EngineType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CallEngine_EngineType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CallEngine_EngineType_KSolidity:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Command

@implementation Command

@dynamic commandOneOfCase;
@dynamic addAssetQuantity;
@dynamic addPeer;
@dynamic addSignatory;
@dynamic appendRole;
@dynamic createAccount;
@dynamic createAsset;
@dynamic createDomain;
@dynamic createRole;
@dynamic detachRole;
@dynamic grantPermission;
@dynamic removeSignatory;
@dynamic revokePermission;
@dynamic setAccountDetail;
@dynamic setAccountQuorum;
@dynamic subtractAssetQuantity;
@dynamic transferAsset;
@dynamic removePeer;
@dynamic compareAndSetAccountDetail;
@dynamic setSettingValue;
@dynamic callEngine;

typedef struct Command__storage_ {
  uint32_t _has_storage_[2];
  AddAssetQuantity *addAssetQuantity;
  AddPeer *addPeer;
  AddSignatory *addSignatory;
  AppendRole *appendRole;
  CreateAccount *createAccount;
  CreateAsset *createAsset;
  CreateDomain *createDomain;
  CreateRole *createRole;
  DetachRole *detachRole;
  GrantPermission *grantPermission;
  RemoveSignatory *removeSignatory;
  RevokePermission *revokePermission;
  SetAccountDetail *setAccountDetail;
  SetAccountQuorum *setAccountQuorum;
  SubtractAssetQuantity *subtractAssetQuantity;
  TransferAsset *transferAsset;
  RemovePeer *removePeer;
  CompareAndSetAccountDetail *compareAndSetAccountDetail;
  SetSettingValue *setSettingValue;
  CallEngine *callEngine;
} Command__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addAssetQuantity",
        .dataTypeSpecific.clazz = GPBObjCClass(AddAssetQuantity),
        .number = Command_FieldNumber_AddAssetQuantity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, addAssetQuantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addPeer",
        .dataTypeSpecific.clazz = GPBObjCClass(AddPeer),
        .number = Command_FieldNumber_AddPeer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, addPeer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addSignatory",
        .dataTypeSpecific.clazz = GPBObjCClass(AddSignatory),
        .number = Command_FieldNumber_AddSignatory,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, addSignatory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appendRole",
        .dataTypeSpecific.clazz = GPBObjCClass(AppendRole),
        .number = Command_FieldNumber_AppendRole,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, appendRole),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createAccount",
        .dataTypeSpecific.clazz = GPBObjCClass(CreateAccount),
        .number = Command_FieldNumber_CreateAccount,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, createAccount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createAsset",
        .dataTypeSpecific.clazz = GPBObjCClass(CreateAsset),
        .number = Command_FieldNumber_CreateAsset,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, createAsset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createDomain",
        .dataTypeSpecific.clazz = GPBObjCClass(CreateDomain),
        .number = Command_FieldNumber_CreateDomain,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, createDomain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createRole",
        .dataTypeSpecific.clazz = GPBObjCClass(CreateRole),
        .number = Command_FieldNumber_CreateRole,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, createRole),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "detachRole",
        .dataTypeSpecific.clazz = GPBObjCClass(DetachRole),
        .number = Command_FieldNumber_DetachRole,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, detachRole),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "grantPermission",
        .dataTypeSpecific.clazz = GPBObjCClass(GrantPermission),
        .number = Command_FieldNumber_GrantPermission,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, grantPermission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removeSignatory",
        .dataTypeSpecific.clazz = GPBObjCClass(RemoveSignatory),
        .number = Command_FieldNumber_RemoveSignatory,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, removeSignatory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "revokePermission",
        .dataTypeSpecific.clazz = GPBObjCClass(RevokePermission),
        .number = Command_FieldNumber_RevokePermission,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, revokePermission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setAccountDetail",
        .dataTypeSpecific.clazz = GPBObjCClass(SetAccountDetail),
        .number = Command_FieldNumber_SetAccountDetail,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, setAccountDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setAccountQuorum",
        .dataTypeSpecific.clazz = GPBObjCClass(SetAccountQuorum),
        .number = Command_FieldNumber_SetAccountQuorum,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, setAccountQuorum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "subtractAssetQuantity",
        .dataTypeSpecific.clazz = GPBObjCClass(SubtractAssetQuantity),
        .number = Command_FieldNumber_SubtractAssetQuantity,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, subtractAssetQuantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transferAsset",
        .dataTypeSpecific.clazz = GPBObjCClass(TransferAsset),
        .number = Command_FieldNumber_TransferAsset,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, transferAsset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "removePeer",
        .dataTypeSpecific.clazz = GPBObjCClass(RemovePeer),
        .number = Command_FieldNumber_RemovePeer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, removePeer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "compareAndSetAccountDetail",
        .dataTypeSpecific.clazz = GPBObjCClass(CompareAndSetAccountDetail),
        .number = Command_FieldNumber_CompareAndSetAccountDetail,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, compareAndSetAccountDetail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setSettingValue",
        .dataTypeSpecific.clazz = GPBObjCClass(SetSettingValue),
        .number = Command_FieldNumber_SetSettingValue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, setSettingValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "callEngine",
        .dataTypeSpecific.clazz = GPBObjCClass(CallEngine),
        .number = Command_FieldNumber_CallEngine,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Command__storage_, callEngine),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Command class]
                                     rootClass:[CommandsRoot class]
                                          file:CommandsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Command__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "command",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Command_ClearCommandOneOfCase(Command *message) {
  GPBDescriptor *descriptor = [Command descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
